// Same contract as overflow_Vulnerability_Example.sol but the vulnerability is fixed with SafeMath

pragma solidity ^0.4.10;

import "./safeMath.sol";

contract Overflow_Example_FIXED {
    
    mapping (address=>uint) balances;
    
    function contribute() public payable {
        balances[msg.sender] = msg.value;
    }

    function getBalance() public constant returns(uint) {
        return balances[msg.sender];
    }
    
    function batchSend(address[] _recievers, uint _value){
// NEW CODE HERE
            // Using safeMath library imported earlier to prevent overflow. Like a proof to make sure the answer is correct mathmaticly
        uint total = SafeMath.mul(_recievers.length, _value);        // safeMath operation will not allow under or over flows
        require(balances[msg.sender]>=total);          
            // For best practices we will use safemath here as well just in case
        balances [msg.sender] = SafeMath.sub(balances[msg.sender], total);
        
        for(uint i=0; i<_recievers.length; i++){
                // Also use SafeMath here
            balances[_recievers[i]] = SafeMath.add(balances[_recievers[i]], _value);
        }
    }
}
