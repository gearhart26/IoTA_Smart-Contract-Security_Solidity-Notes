// To make vulnerability work we just need to specify 2 addresses and input 
// 0x8000000000000000000000000000000000000000000000000000000000000000
// to make the batchSend function overflow and set total to 0 while also sending an enormous amout to both addresses

    //This is the old version that these contracts ran on at the time of the vulnerability
pragma solidity ^0.4.10;

    //Example of what happened with Beauty Chain Overflow vulnerability 
contract Overflow_Example {
    
        //a mapping data structure from adress to integer to hold all the balances
    mapping (address=>uint) balances;
    
        //a function that gives out tokens based on amount of real ETH deposited
    function contribute() public payable {
            //Takes the amount of ETH and saves the specified amount of tokens to the users balance to represent their deposited ETH
            //This line saves eth to token conversion of 1 wei = 1 token
                //but could easilly be changed to "balances[msg.sender] = 100 * msg.value;" to make the conversion 1 wei = 100 tokens
        balances[msg.sender] = msg.value;
    }
        //constant makes it so that you do not have to spend gas to run the function
    function getBalance() public constant returns(uint) {
        return balances[msg.sender];
    }
    
// This is where the vulnerability will be
    function batchSend(address[] _recievers, uint _value){
        
        //this is the line that causes the overflow
        uint total = _recievers.length * _value;        //uint total can hold up to 256 bits but it can still overflow
        require(balances[msg.sender]>=total);           //this require() statement is useless if total overflows
        
            //subtract from senders balance
        balances [msg.sender] = balances[msg.sender] - total;
        
            //checks each _recievers balance and adds the amout being sent to their balance looping through all _recievers
        for(uint i=0; i<_recievers.length; i++){
            balances[_recievers[i]] = balances[_recievers[i]] + _value;
        }
    }
}




// Same contract but the vulnerability is fixed with SafeMath
pragma solidity ^0.4.10;
import "./SafeMath.sol";

contract Overflow_Example_FIXED {
    
    mapping (address=>uint) balances;
    
    function contribute() public payable {
        balances[msg.sender] = msg.value;
    }

    function getBalance() public constant returns(uint) {
        return balances[msg.sender];
    }
    
    function batchSend(address[] _recievers, uint _value){
// NEW CODE HERE
            // Using safeMath library imported earlier to prevent overflow. Like a proof to make sure the answer is correct mathmaticly
        uint total = SafeMath.mul(_recievers.length, _value);        // safeMath operation will not allow under or over flows
        require(balances[msg.sender]>=total);          
            // For best practices we will use safemath here as well just in case
        balances [msg.sender] = SafeMath.sub(balances[msg.sender], total);
        
        for(uint i=0; i<_recievers.length; i++){
                // Also use SafeMath here
            balances[_recievers[i]] = SafeMath.add(balances[_recievers[i]], _value);
        }
    }
}
